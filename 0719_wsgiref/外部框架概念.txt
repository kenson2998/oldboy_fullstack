

外部服務器 : 用於解析HTTP協議
Apache 、 Nginx

外部應用: 用於和外部服務器溝通

外部框架
Django Flask


外部服務網關接口:
WSGI
外部框架和外部服務器溝通是透過WSGI(Web Server Gateway Interface)

MVC架構與MTV架構

Model 模型:
負責業務對象與數據庫對象(ORM)

Control 控制:
接收客戶輸入調用模型和視圖完成用戶的請求

Template 模板:
負責如何把頁面展示給用戶

View 視圖:
負責用戶的交互(頁面)


Django 可以叫MTV也可以叫MVC
你跟Java、PHP的說 MTV他們不懂

創建指令
django-admin startproject mysite
python manage.py startapp blog

views.py 中的 return render() 其實也是回傳HttpResponse
頁面渲染:
render(request,"register.html")
return render_to_response("register.html")  不需要回傳request

頁面跳轉:
redirect("路徑")
locals() 可以將函數中所有變量傳給模板


setting.py
STATIC_URL = '/statics/'  # 別名
這個別名用來統一HTML文件上的 statics 路徑 都會依別名在前端呈現
本地目錄可能是別的目錄名 假如是abc
STATIC_URL = '/statics/'  # 別名

STATICFILES_DIRS = (
    os.path.join(BASE_DIR,"abc"),
)

HTML裡面依舊是static不用再去HTML修改路徑
 <script src="/static/xxx.js"></script>
 一樣還是 <script src="/static/xxx.js"></script>
 但本地會去abc/xxx.js



 HTML 前面加上
 {% load staticfiles %}
 後面的static可以這樣改
 <script src="/static/xxx.js"></script>
 <script src="{% static 'jquery-3.4.1.min.js' %}"></script>




 420集
 把statics 丟到 blog 並修改setting.py
STATICFILES_DIRS = (
    os.path.join(BASE_DIR, "blog","statics"),
)

urls.py
url(r'article/\d{4}', views.article_year),
給任何四個數字就可以訪問,但如果要取值的話要加()
url(r'article/(\d{4})', views.article_year),

views.py 就能撈到這個東西,這邊用year當行參
def article_year(request,year):
    return HttpResponse(year)

用 ?P<> 來進行分組
url(r'article_year_month/(?P<year>\d{4})/(?P<month>\d{2})', views.article_year_month),
這邊使用 year 和 month , 所以 views.py 裡面就要用相同的變數名稱
def article_year_month(request, year, month):
    return HttpResponse(year + month)


urlpatterns = [
    url(正則表達式, views視圖函數, 參數, 別名),
]

別名:
url(r'register/', views.register, name="reg"),
html裡面就可以使用 {% url reg %}
<form action="{% url reg %}" method="post">
渲染過後:
<form action="/register/" method="post">


421集 分發
mysite/urls.py 裡面放include blog , 這樣就可以分開使用urls.py
url(r'^blog/', include('blog.urls')),

blog/urls.py 下次訪問時 http://localhost:8080/blog/xxxx 以blog為開頭
把剛剛寫的register放到blog/urls.py
url(r'register/', views.register, name="reg"),
這樣就可以訪問使用register
http://localhost:8080/blog/register/


422集
request可調用的東西
print("return url_path:", request.path)
print("return url_path:", request.get_full_path())

{{ }}<~ 模板語言

寫一個登入頁面:
login.html
用 request.POST.get("user") 驗證帳號登入

423集

redriect 的用處: 會帶你跳轉到login的視圖函數去處理


if request.POST.get("user") == "leon":
    # return redirect("/login/") # 使用 redirect 會跳轉到 login url 的函數去處理
    return render(request, "login.html", locals())  # <~ 用render會跳轉頁面,但是url還是原本的register,重整頁面會回到未登入


424集

render 和 redriect 的區別
1. 如果render 的頁面需要{{模板語言}}渲染,除了register需要寫變數, login 也要再寫,代碼會重複
2. 最重要的差別在於網址一個還是在register,一個會跳轉到login去處理 ,重新整理以後,又要重新登錄


return HttpResponse 寫法缺點：
1. 維護代價高
2. 前端發開者必須了解python
3. 效率低, 前端必須等待後端開發完成,才能寫前端


進入Django專案的環境：
python manage.py shell
from django.template import Context, Template
t = Template("my name is {{ name }} . ")
c = Context({"name":"Leon"})
t.render(c)

'my name is Leon .'

#low
for name in ('alex','leon','leo'):
    t = Template("my name is {{ name }}")
    print(t.render(Context({"name" : name })))

#good

t = Template("my name is {{ name }}")
for name in ('alex','leon','leo'):
    print(t.render(Context({"name" : name })))


模板語言:
深度查詢用句點符號 :
l = ['123','456','789']
{{l.0}}  = 123
d = {'name':'cat'}
{{ d.name}}  =  cat
c = role("leon")
{{c.Name}} = leon